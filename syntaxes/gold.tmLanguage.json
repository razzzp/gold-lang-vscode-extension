{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Gold",
	"patterns": [
		{ "include": "#comments"},
		{ "include": "#declaration"},
		{ "include": "#keyword"},
		{ "include": "#storage"},
		{ "include": "#constant"}
	],
	"repository": {		
		"comments": {
			"name": "comment.line",
			"begin": ";",
			"end": "[\n\r]"
		},


		"declaration": {
			"patterns": [
				{"include": "#class-declaration"},
				{"include": "#function-declaration"},
				{"include": "#procedure-declaration"},
				{"include": "#variable-class-declaration"}
			]
		},
		"class-declaration":{
			"name": "meta.class",
			"comment": "Labels class name and inherited class name, end impossible to match so will go to end of file",
			"match": "\\b(?:(class)\\s+)(?:(\\w+))?(?:\\s*\\(([\\w]+)\\))?",
			"captures": {
				"1": { "name": "storage.type.class"},
				"2": { "patterns": [{"include": "#class-name"}]},
				"3": { "name": "entity.other.inherited-class"}
			}
		},
		"function-declaration":{
			"name": "meta.function",
			"patterns": [
				{"include": "#function-declaration-start"},
				{"include": "#function-declaration-end"}
			]
		},
		"function-declaration-start":{
			"name": "meta.function.start",
			"comment": "function {funcName} ({parameters}) return [return-type] [protected/private] [override/final]",
			"match": "\\b(function)\\s+(\\w+)(?:\\s*(\\([^)]*\\)?))?(?:\\s*(return)(?:\\s+([\\w]+))?)?(?:\\s+([\\w]+))?(?:\\s+([\\w]+))?",
			"captures": {
				"1": { "name": "storage.type.function" },
				"2": { "patterns": [{"include": "#function-name"}]},
				"3": { "patterns": [
					{"include": "#parameters"}
				]},
				"4": { "name": "keyword.control.flow"},
				"5": { "name": "meta.function.return-type","patterns": [{"include": "#type-name"}]},
				"6": { "patterns": [{"include": "#storage-modifier"}]},
				"7": { "patterns": [{"include": "#storage-modifier-method"}]}
			}
		},
		"function-declaration-end": {
			"name": "meta.function.end",
			"comment": "",
			"match": "\\b(endFunc)\\b",
			"captures": {
				"1": { "name": "storage.type.function"}
			}
		},
		"procedure-declaration":{
			"name": "meta.procedure",
			"patterns": [
				{"include": "#procedure-declaration-start"},
				{"include": "#procedure-declaration-end"}
			]
		},
		"procedure-declaration-start":{
			"name": "meta.procedure.start",
			"comment": "procedure {procName} ({parameters}) [protected/private] [override/final]",
			"match": "\\b(procedure)\\s+(\\w+)(?:\\s*(\\([^)]*\\)?))?(?:\\s*([\\w]+))?(?:\\s+([\\w]+))?",
			"captures": {
				"1": { "name": "storage.type.procedure" },
				"2": { "patterns": [{"include": "#procedure-name"}]},
				"3": { "patterns": [
					{"include": "#parameters"}
				]},
				"4": { "name": "storage.modifier"},
				"5": { "name": "storage.modifier"}
			}
		},
		"procedure-declaration-end": {
			"name": "meta.procedure.end",
			"comment": "",
			"match": "\\b(endProc)\\b",
			"captures": {
				"1": { "name": "storage.type.procedure"}
			}
		},
		"variable-class-declaration": {
			"name": "meta.definition.variable.class",
			"comment": "[memory]? {variableName} : [refTo/listOf] '[P,A,T]' {var-type}",
			"match": "\\b(?:(memory)\\s+)?(?:(\\w+)\\s*)?(?:(\\:)\\s*)(?:(refTo|listOf)\\s*(\\[[A-Za-z,\\s]*\\])?\\s*)?(?:(\\w+))?",
			"captures": {
				"1": {"name": "storage.modifier.variable.class"},
				"2": {"patterns": [{"include": "#variable-name-class"}]},
				"3": {"name": "keyword.operator.type.annotation"},
				"4": {"patterns": [{"include": "#storage-modifier-variable-class"}]},
				"5": {"patterns": [{"include": "#storage-modifier-reference"}]},
				"6": {"patterns": [{"include": "#type-name"}]}
			}
		},
		"parameters" : {
			"name": "meta.parameters",
			"comment": "([var|const|inOut] {paramName} : {paramType}, ...)",
			"begin": "\\(",
			"patterns": [{"include": "#variable-parameters-declarations"}],
			"end": "\\)"
		},
		"variable-parameters-declarations": {
			"match": "\\b([\\w\\:\\s]+)(?:\\*,\\s*([\\w\\:\\s]+))?",
			"comment": "recursive regex for multiple parameters",
			"captures": {
				"1": {
					"patterns": [
						{"include": "#variable-parameters-declaration"},
						{"include": "#variable-parameters-declaration-like"}
					]
				},
				"2": {"patterns": [{"include": "#variable-parameters-declarations"}]}
			}
		},
		"variable-parameters-declaration": {
			"match": "\\b(?:(const|inOut|var)\\s+)?(?:(\\w+))(?:\\s*(\\:)\\s*)(?:(\\w+))?",
			"captures": {
				"1": {"patterns": [{"include": "#storage-modifier-variable-parameters"}]},
				"2": {"patterns": [{"include": "#variable-name-class"}]},
				"3": {"name": "keyword.operator.type.annotation"},
				"4": {"patterns": [{"include": "#type-name"}]}
			}
		},
		"variable-parameters-declaration-like": {
			"match": "\\b(?:(const|inOut|var))(?:\\s+(\\w+))?",
			"captures": {
				"1": {"patterns": [{"include": "#storage-modifier-variable-parameters"}]},
				"2": {"patterns": [{"include": "#variable-name-class"}]}
			}
		},


		"entity-name": {
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"type-name": {
			"name": "entity.name.type",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"class-name": {
			"name": "entity.name.class",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"function-name": {
			"name": "entity.name.function",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"procedure-name": {
			"name": "entity.name.function.procedure",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"variable-name-class": {
			"name": "variable.class",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},


		"storage": {
			"patterns": [
				{ "include": "#storage-class"},
				{ "include": "#storage-function"},
				{ "include": "#storage-procedure"},
				{ "include": "#storage-modifier-all"}
			]
		},
		"storage-class": {
			"name": "storage.type",
			"match": "\\bclass\\b"
		},
		"storage-function": {
			"name": "storage.type",
			"match": "\\bfunction\\b"
		},
		"storage-procedure": {
			"name": "storage.type",
			"match": "\\bprocedure\\b"
		},
		"storage-modifier-all": {
			"patterns": [
				{"include": "#storage-modifier"},
				{"include": "#storage-modifier-method"},
				{"include": "#storage-modifier-variable-parameters"},
				{"include": "#storage-modifier-variable-class"},
				{"include": "#storage-modifier-reference"}
			]
		},
		"storage-modifier": {
			"name": "storage.modifier",
			"match": "\\b(protected|private)\\b"
		},
		"storage-modifier-method": {
			"name": "storage.modifier.method",
			"match": "\\b(override|final)\\b",
			"include": "#storage-modifier"
		},
		"storage-modifier-variable-parameters": {
			"name": "storage.modifier.variable",
			"match": "\\b(const|inOut|var)\\b"
		},
		"storage-modifier-variable-class": {
			"name": "storage.modifier.variable.class",
			"match": "\\b(memory|refTo|listOf)\\b",
			"include": "#storage-modifier"
		},
		"storage-modifier-reference": {
			"name": "storage.modifier.reference.annotation",
			"comment": "TODO",
			"begin": "\\[",
			"end": "\\]",
			"match": ""
		},


		"keyword": {
			"patterns": [
				{ "include": "#keyword-control"}
			]
		},
		"keyword-control": {
			"patterns": [
				{ "include": "#keyword-control-conditional-start"},
				{ "include": "#keyword-control-conditional-intermediate"},
				{ "include": "#keyword-control-conditional-end"},
				{ "include": "#keyword-control-loop-start"},
				{ "include": "#keyword-control-loop-end"},
				{ "include": "#keyword-control-trycatch"}
			]
		},
		"keyword-control-conditional-start": {
			"name": "keyword.control.conditional",
			"match": "\\b(if|switch|when)\\b"
		},
		"keyword-control-conditional-intermediate": {
			"name": "keyword.control.conditional",
			"match": "\\b(elseif|else)\\b"
		},
		"keyword-control-conditional-end": {
			"name": "keyword.control.conditional",
			"match": "\\b(endIf|endSwitch|endWhen)\\b"
		},
		"keyword-control-loop-start": {
			"name": "keyword.control.loop",
			"match": "\\b(while|for|forEach|loop|repeat)\\b"
		},
		"keyword-control-loop-end": {
			"name": "keyword.control.loop",
			"match": "\\b(endWhile|endFor|endLoop|until)\\b"
		},
		"keyword-control-trycatch": {
			"name": "keyword.control.trycatch",
			"match": "\\b(try|catch|finally|endTry)\\b"
		},
		"keyword-control-flow": {
			"name": "keyword.control.flow",
			"match": "\\b(return|exit|break|continue)\\b"
		},


		"constant":{
			"patterns": [
				{"include": "#constant-boolean"},
				{"include": "#constant-nil"},
				{"include": "#constant-integer"},
				{"include": "#constant-decimal"},
				{"include": "#constant-character"},
				{"include": "#constant-string-single"},
				{"include": "#constant-string-double"}
			]
		},
		"constant-boolean":{
			"name": "constant.language.boolean",
			"match": "\\b(true|True|false|False)\\b"
		},
		"constant-nil":{
			"name": "constant.language.nil",
			"match": "\\b(nil|Nil)\\b"
		},
		"constant-integer":{
			"name": "constant.numeric.integer",
			"match": "\\b\\d+\\b"
		},
		"constant-decimal":{
			"name": "constant.numeric.decimal",
			"match": "\\b\\d+(\\.\\d*)?\\b"
		},
		"constant-character":{
			"name": "constant.character",
			"match": "#\\d{1,3}\\b"
		},
		"constant-string-single": {
			"name": "string.quoted.single.gold",
			"begin": "'",
			"end": "'",
			"patterns": [
				{
					"name": "constant.character.single-quote.escape.gold",
					"match": "''"
				}
			]
		},
		"constant-string-double": {
			"name": "string.quoted.single.gold",
			"begin": "\"",
			"end": "\""
		}
	},
	"scopeName": "source.gold"
}