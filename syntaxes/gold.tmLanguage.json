{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Gold",
	"patterns": [
		{"include": "#comments"},
		{"include": "#declaration"},
		{"include": "#statement"},
		{"include": "#keyword"},
		{"include": "#constant"},
		{"include": "#variable"}
	],
	"repository": {		
		"comments": {
			"name": "comment.line",
			"begin": ";",
			"end": "[\n\r]"
		},


		"declaration": {
			"patterns": [
				{"include": "#class-declaration"},
				{"include": "#function-declaration"},
				{"include": "#procedure-declaration"},
				{"include": "#variable-class-declaration"},
				{"include": "#variable-local-declaration"}
			]
		},
		"class-declaration":{
			"name": "meta.class",
			"comment": "Labels class name and inherited class name, end impossible to match so will go to end of file",
			"match": "\\b(?:(class)\\s+)(?:(\\w+))?(?:\\s*\\(([\\w]+)\\))?",
			"captures": {
				"1": { "name": "storage.type.class"},
				"2": { "patterns": [{"include": "#class-name"}]},
				"3": { "name": "entity.other.inherited-class"}
			}
		},
		"function-declaration":{
			"name": "meta.function",
			"patterns": [
				{"include": "#function-declaration-start"},
				{"include": "#function-declaration-end"}
			]
		},
		"function-declaration-start":{
			"name": "meta.function.start",
			"comment": "function {funcName} ({parameters}) return [return-type] [protected/private] [override/final]",
			"match": "\\b(function)\\s+(\\w+)(?:\\s*(\\([^)]*\\)?))?(?:\\s*(return)(?:\\s+([\\w]+))?)?(?:\\s+([\\w\\s]+))?",
			"captures": {
				"1": { "name": "storage.type.function" },
				"2": { "patterns": [{"include": "#function-name"}]},
				"3": { "patterns": [
					{"include": "#parameters-declaration"}
				]},
				"4": { "name": "keyword.control.flow"},
				"5": { "name": "meta.function.return-type","patterns": [{"include": "#type-name"}]},
				"6": { "patterns": [{"include": "#storage-modifier-method-list"}]}
			}
		},
		"function-declaration-end": {
			"name": "meta.function.end",
			"comment": "",
			"match": "\\b(endFunc)\\b",
			"captures": {
				"1": { "name": "storage.type.function"}
			}
		},
		"procedure-declaration":{
			"name": "meta.procedure",
			"patterns": [
				{"include": "#procedure-declaration-start"},
				{"include": "#procedure-declaration-end"}
			]
		},
		"procedure-declaration-start":{
			"name": "meta.procedure.start",
			"comment": "procedure {procName} ({parameters}) [protected/private] [override/final]",
			"match": "\\b(procedure)\\s+(\\w+)(?:\\s*(\\([^)]*\\)?))?(?:\\s*([\\w\\s]+))?",
			"captures": {
				"1": { "name": "storage.type.procedure" },
				"2": { "patterns": [{"include": "#procedure-name"}]},
				"3": { "patterns": [
					{"include": "#parameters-declaration"}
				]},
				"4": { "patterns": [{"include": "#storage-modifier-method-list"}]}
			}
		},
		"procedure-declaration-end": {
			"name": "meta.procedure.end",
			"comment": "",
			"match": "\\b(endProc)\\b",
			"captures": {
				"1": { "name": "storage.type.procedure"}
			}
		},
		"variable-class-declaration": {
			"name": "meta.definition.variable.class",
			"comment": "[memory]? {variableName} : [refTo/listOf] '[P,A,T]' {var-type}",
			"match": "\\b(?:(memory)\\s+)?(?:(\\w+)\\s*)?(?:(\\:)\\s*)(?:(refTo|listOf)\\s*(\\[[A-Za-z,\\s]*\\])?\\s*)?(?:(\\w+))?(?:\\s+(?!inverse)([\\w\\s]+))?(?:\\s+(inverse)\\s+(\\w+))?",
			"captures": {
				"1": {"name": "storage.modifier.variable.class"},
				"2": {"patterns": [{"include": "#variable-name-class"}]},
				"3": {"name": "keyword.operator.type.annotation"},
				"4": {"patterns": [{"include": "#storage-modifier-variable-class"}]},
				"5": {"patterns": [{"include": "#storage-modifier-references"}]},
				"6": {"patterns": [{"include": "#type-name"}]},
				"7": {"patterns": [{"include": "#storage-modifier-scope-list"}]},
				"8": {"patterns": [{"include": "#storage-modifier-variable-class"}]},
				"9": {"patterns": [{"include": "#variable-name-class"}]}
			}
		},
		"parameters-declaration" : {
			"name": "meta.parameters",
			"comment": "([var|const|inOut] {paramName} : {paramType}, ...)",
			"begin": "\\(",
			"patterns": [{"include": "#variable-parameters-declaration-list"}],
			"end": "\\)"
		},
		"variable-parameters-declaration-list": {
			"match": "\\b([\\w\\:\\s]+)(?:\\s*,\\s*([\\w\\:\\s,]+))?",
			"comment": "recursive regex for multiple parameters",
			"captures": {
				"1": {
					"patterns": [
						{"include": "#variable-parameters-declaration"},
						{"include": "#variable-parameters-declaration-like"},
						{"include": "#variable-parameters-declaration-like-nomodifier"}
					]
				},
				"2": {"patterns": [{"include": "#variable-parameters-declaration-list"}]}
			}
		},
		"variable-parameters-declaration": {
			"match": "\\b(?:(const|inOut|var)\\s+)?(?:(\\w+))(?:\\s*(\\:)\\s*)(?:(\\w+))?",
			"captures": {
				"1": {"patterns": [{"include": "#storage-modifier-variable-parameters"}]},
				"2": {"patterns": [{"include": "#variable-name-class"}]},
				"3": {"name": "keyword.operator.type.annotation"},
				"4": {"patterns": [{"include": "#type-name"}]}
			}
		},
		"variable-parameters-declaration-like": {
			"match": "\\b(?:(const|inOut|var))(?:\\s+(\\w+))?",
			"captures": {
				"1": {"patterns": [{"include": "#storage-modifier-variable-parameters"}]},
				"2": {"patterns": [{"include": "#variable-name-class"}]}
			}
		},
		"variable-parameters-declaration-like-nomodifier": {
			"match": "\\b(?:(\\w+))",
			"captures": {
				"1": {"patterns": [{"include": "#variable-name-class"}]}
			}
		},
		"variable-local-declaration": {
			"name": "meta.definition.variable.local",
			"comment": "var {variableName} : {var-type}",
			"match": "\\b(?:(var)\\s+)(\\w+)?(?:\\s*(\\:)\\s*)?(\\w+)?",
			"captures": {
				"1": {"name": "storage.modifier.variable.local"},
				"2": {"patterns": [{"include": "#variable-name-local"}]},
				"3": {"name": "keyword.operator.type.annotation"},
				"4": {"patterns": [{"include": "#type-name"}]}
			}
		},


		"statement": {
			"patterns": [
				{"include": "#access-recursive"},
				{"include": "#function-call"}
			]
		},
		"access-recursive" :{
			"comment": "PROBABLY CAN EASILY BREAK THINGS :D. Disabled for now. TO REVIEW. TODO",
			"match": "\\b([^\\.\\S]+)(?:\\s*(\\.)\\s*)(.*)",
			"disabled": 1,
			"captures": {
				"1": {
					"patterns": [
						{"include": "#function-call"},
						{"include": "#variable"}
					]},
				"2": {"name": "keyword.operator.access-property"},
				"3": {"patterns": [
					{"include": "#access-recursive"},
					{"include": "#function-call"},
					{"include": "#variable"}
					]}
			}
		},
		"function-call" :{
			"name": "meta.function-call",
			"begin": "\\b(\\w+)\\(",
			"beginCaptures": {
				"1": {"patterns": [{"include": "#function-name"}]}
			},
			"end": "\\)",
			"patterns": [
				{"include": "#statement"},
				{"include": "#keyword"},
				{"include": "#constant"},
				{"include": "#variable"},
				{"include": "#entity-name"}
			],
			"contentName":"meta.function-call.parameters"
		},
		"parameters-list":{
			"match": ".*?",
			"comment": "recursive rule for multiple parameters",
			"patterns": [
				{"include": "#statement"},
				{"include": "#keyword"},
				{"include": "#constant"},
				{"include": "#variable"},
				{"include": "#entity-name"}
			]
		},
		"parameter":{
			"patterns": [{"include": "#statement"}]
		},
		

		"entity-name": {
			"patterns": [
				{"include": "#variable"},
				{"include": "#type-name"},
				{"include": "#class-name"},
				{"include": "#function-name"},
				{"include": "#procedure-name"},
				{"include": "#variable-name-local"},
				{"include": "#variable-name-class"}
			]
		},
		"variable": {
			"name": "variable.other",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"type-name": {
			"name": "entity.name.type",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"class-name": {
			"name": "entity.name.class",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"function-name": {
			"name": "entity.name.function",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"procedure-name": {
			"name": "entity.name.function.procedure",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"variable-name-local": {
			"name": "variable.local",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},
		"variable-name-class": {
			"name": "variable.class",
			"match": "\\b[A-Za-z_]\\w*\\b"
		},



		"storage": {
			"patterns": [
				{ "include": "#storage-class"},
				{ "include": "#storage-function"},
				{ "include": "#storage-procedure"},
				{ "include": "#storage-modifier-all"},
				{ "include": "#storage-type"}
			]
		},
		"storage-class": {
			"name": "storage.type",
			"match": "\\bclass\\b"
		},
		"storage-function": {
			"name": "storage.type",
			"match": "\\bfunction|func\\b"
		},
		"storage-procedure": {
			"name": "storage.type",
			"match": "\\bprocedure|proc\\b"
		},
		"storage-type": {
			"name": "storage.type",
			"match": "\\btype\\b"
		},
		"storage-modifier-all": {
			"patterns": [
				{"include": "#storage-modifier-scope"},
				{"include": "#storage-modifier-variable-parameters"},
				{"include": "#storage-modifier-variable-class"},
				{"include": "#storage-modifier-reference"}
			]
		},
		"storage-modifier-scope": {
			"name": "storage.modifier.scope",
			"match": "\\b(protected|private|override|final)\\b"
		},
		"storage-modifier-scope-list": {
			"match": "\\b(\\w+)(?:\\s+([\\w\\s]+))?",
			"captures": {
				"1": {"patterns": [{"include": "#storage-modifier-scope"}]},
				"2": {"patterns": [{"include": "#storage-modifier-scope-list"}]}
			}
		},
		"storage-modifier-method": {
			"name": "storage.modifier.scope",
			"match": "\\b(forward)\\b"
		},
		"storage-modifier-method-list": {
			"match": "\\b(\\w+)(?:\\s+([\\w\\s]+))?",
			"captures": {
				"1": {"patterns": [
					{"include": "#storage-modifier-scope"},
					{"include": "#storage-modifier-method"}
					]},
				"2": {"patterns": [{"include": "#storage-modifier-scope-list"}]}
			}
		},
		"storage-modifier-variable-class-list": {
			"match": "\\b(\\w+)(?:\\s+([\\w\\s]+))?",
			"captures": {
				"1": {"patterns": [
					{"include": "#storage-modifier-scope"},
					{"include": "#storage-modifier-method"}
					]},
				"2": {"patterns": [{"include": "#storage-modifier-scope-list"}]}
			}
		},
		"storage-modifier-variable-parameters": {
			"name": "storage.modifier.variable",
			"match": "\\b(const|inOut|inout|var)\\b"
		},
		"storage-modifier-variable-class": {
			"name": "storage.modifier.variable.class",
			"match": "\\b(memory|refTo|refto|listOf|listof|inverse)\\b"
		},
		"storage-modifier-references": {
			"comment": "'[' [V | Versioned | IsVersioned | T | InTransaction | O |  IsOwner | P |  IsCurProject | I | IsIntegral | A | IsActive] ']'",
			"begin": "\\[",
			"end": "\\]",
			"patterns": [{"include": "#storage-modifier-reference-list"}]
		},
		"storage-modifier-reference-list": {
			"match": "\\b(?:([A-Za-z]+))(?:\\s*,\\s*([A-Za-z,\\s]+))?",
			"comment": "recursive annotations",
			"captures": {
				"1": {"patterns":[{"include": "#storage-modifier-reference"}]},
				"2": {"patterns": [{"include": "#storage-modifier-reference-list"}]}
			}
		},
		"storage-modifier-reference": {
			"name": "storage.modifier.reference",
			"comment": "matchine single reference annotation",
			"match": "\\b(Versioned|IsVersioned|InTransaction|IsOwner|IsCurProject|IsIntegral|IsActive|V|T|O|P|I|A)\\b"
		},


		"keyword":{
			"patterns": [
				{"include": "#keyword-control"},
				{"include": "#keyword-operator"},
				{"include": "#storage"}
			]
		},
		"keyword-control": {
			"patterns": [
				{ "include": "#keyword-control-conditional-start"},
				{ "include": "#keyword-control-conditional-intermediate"},
				{ "include": "#keyword-control-conditional-end"},
				{ "include": "#keyword-control-loop-start"},
				{ "include": "#keyword-control-loop-end"},
				{ "include": "#keyword-control-trycatch"}
			]
		},
		"keyword-control-conditional-start": {
			"name": "keyword.control.conditional",
			"match": "\\b(if|switch|when)\\b"
		},
		"keyword-control-conditional-intermediate": {
			"name": "keyword.control.conditional",
			"match": "\\b(elseif|elseIf|else)\\b"
		},
		"keyword-control-conditional-end": {
			"name": "keyword.control.conditional",
			"match": "\\b(endIf|endif|endSwitch|endswitch|endWhen|endwhen)\\b"
		},
		"keyword-control-loop-start": {
			"name": "keyword.control.loop",
			"match": "\\b(while|for|forEach|foreach|loop|repeat)\\b"
		},
		"keyword-control-loop-end": {
			"name": "keyword.control.loop",
			"match": "\\b(endWhile|endwhile|endFor|endfor|endLoop|endloop|until)\\b"
		},
		"keyword-control-trycatch": {
			"name": "keyword.control.trycatch",
			"match": "\\b(try|catch|finally|endTry|endtry)\\b"
		},
		"keyword-control-flow": {
			"name": "keyword.control.flow",
			"match": "\\b(return|exit|break|continue)\\b"
		},
		"keyword-operator":{
			"patterns": [
				{"include": "#keyword-operator-arithmetic"},
				{"include": "#keyword-operator-string"},
				{"include": "#keyword-operator-shift"},
				{"include": "#keyword-operator-comparison"},
				{"include": "#keyword-operator-logical"},
				{"include": "#keyword-operator-bitwise"},
				{"include": "#keyword-operator-other"},
				{"include": "#keyword-operator-other-words"}
			]
		},
		"keyword-operator-arithmetic":{
			"name": "keyword.operator.arithmetic",
			"match": "(\\+\\+|\\*|\\/|%|\\+|-)"
		},
		"keyword-operator-string":{
			"name": "keyword.other.operator.string",
			"match": "(&&|\\blike\\b)"
		},
		"keyword-operator-shift":{
			"name": "keyword.operator.shift",
			"match": "(>>|<<)"
		},
		"keyword-operator-assignment":{
			"name": "keyword.operator.comparison",
			"match": "(=|:=)"
		},
		"keyword-operator-comparison":{
			"name": "keyword.operator.comparison",
			"match": "(<>|<=|>=|<|>|=)"
		},
		"keyword-operator-logical":{
			"name": "keyword.other.operator.logical",
			"match": "\\b(and|or|not|xor)\\b"
		},
		"keyword-operator-bitwise":{
			"name": "keyword.other.operator.bitwise",
			"match": "\\b(bAnd|bOr|bNot|bXor)\\b"
		},
		"keyword-operator-in":{
			"name": "keyword.other.operator.in",
			"match": "\\b(in)\\b"
		},
		"keyword-operator-other":{
			"name": "keyword.operator.other",
			"match": "(@|\\.)"
		},
		"keyword-operator-other-words":{
			"name": "keyword.other.operator.other",
			"match": "\\b(uses|inverse)\\b"
		},



		"constant":{
			"patterns": [
				{"include": "#constant-boolean"},
				{"include": "#constant-nil"},
				{"include": "#constant-integer"},
				{"include": "#constant-decimal"},
				{"include": "#constant-character"},
				{"include": "#constant-string-single"},
				{"include": "#constant-string-double"}
			]
		},
		"constant-boolean":{
			"name": "constant.language.boolean",
			"match": "\\b(true|True|false|False)\\b"
		},
		"constant-nil":{
			"name": "constant.language.nil",
			"match": "\\b(nil|Nil)\\b"
		},
		"constant-integer":{
			"name": "constant.numeric.integer",
			"match": "\\b(\\d+)\\b"
		},
		"constant-decimal":{
			"name": "constant.numeric.decimal",
			"match": "\\b(\\d+(?:\\.\\d*)?)\\b"
		},
		"constant-character":{
			"name": "constant.character",
			"match": "(#\\d{1,3}\\b)"
		},
		"constant-string-single": {
			"name": "string.quoted.single.gold",
			"begin": "'",
			"end": "'(?=[^']|$)",
			"patterns": [
				{
					"name": "constant.character.single-quote.escape.gold",
					"match": "''"
				}
			]
		},
		"constant-string-double": {
			"name": "string.quoted.single.gold",
			"begin": "\"",
			"end": "\""
		}
	},
	"scopeName": "source.gold"
}